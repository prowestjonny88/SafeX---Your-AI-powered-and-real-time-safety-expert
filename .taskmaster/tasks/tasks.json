{
  "tasks": [
    {
      "id": 1,
      "title": "Add All Missing Gradle Dependencies",
      "description": "Add all required dependencies to app/build.gradle.kts: Room (runtime + KSP compiler), Navigation-Compose, WorkManager, DataStore-Preferences, CameraX (camera2 + lifecycle + view), ML Kit (text-recognition, barcode-scanning, language-id, translate), TFLite (task-library-text), Firebase Auth, Lifecycle-ViewModel-Compose, Material Icons Extended, Accompanist Permissions, Coil, Chrome Custom Tabs, Retrofit/OkHttp (for GDELT), Kotlin Serialization. Also add KSP plugin to build.gradle.kts for Room annotation processing. DI framework is TBD (Hilt or Koin — leave a TODO comment noting this decision is pending).",
      "details": "Current dependencies: Compose BOM, core-ktx, lifecycle-runtime, activity-compose, material3, Firebase Firestore, Firebase Functions. All other dependencies are missing. This is a blocking task for all subsequent work.",
      "testStrategy": "Gradle sync succeeds without errors. All imports resolve in IDE.",
      "status": "pending",
      "dependencies": [],
      "priority": "high",
      "subtasks": []
    },
    {
      "id": 2,
      "title": "Configure KSP Plugin for Room",
      "description": "Add the KSP (Kotlin Symbol Processing) plugin to the project for Room annotation processing. Add to root build.gradle.kts and app/build.gradle.kts.",
      "details": "Required for Room's @Entity, @Dao, @Database annotations to generate implementation code at compile time.",
      "testStrategy": "Build succeeds with Room annotations present.",
      "status": "pending",
      "dependencies": [1],
      "priority": "high",
      "subtasks": []
    },
    {
      "id": 3,
      "title": "Create Package Structure",
      "description": "Create the full package directory structure under com.safex.app: data/local (Room DAOs, DB), data/remote (Cloud Functions client, GDELT API), data/model (entities, DTOs, enums), data/repository, domain (use cases if needed), ui/home, ui/alerts, ui/insights, ui/settings, ui/scan, ui/onboarding, ui/components (shared composables), service (NotificationListenerService), worker (WorkManager workers), detection (triage engine, heuristics, TFLite), di (dependency injection module).",
      "details": "Only create directories and placeholder package-info or empty files to establish the structure. Do not implement logic yet.",
      "testStrategy": "All packages visible in IDE; project compiles.",
      "status": "pending",
      "dependencies": [],
      "priority": "high",
      "subtasks": []
    },
    {
      "id": 4,
      "title": "Update AndroidManifest with All Permissions and Service Declarations",
      "description": "Add all required permissions to AndroidManifest.xml: INTERNET, POST_NOTIFICATIONS, READ_MEDIA_IMAGES (API 33+), READ_EXTERNAL_STORAGE (fallback <33), CAMERA, FOREGROUND_SERVICE. Declare SafeXNotificationListenerService with BIND_NOTIFICATION_LISTENER_SERVICE permission and intent-filter. Declare WorkManager initializer if needed.",
      "details": "POST_NOTIFICATIONS is runtime permission on API 33+. READ_MEDIA_IMAGES replaces READ_EXTERNAL_STORAGE on API 33+. NotificationListenerService needs special declaration with intent-filter for android.service.notification.NotificationListenerService.",
      "testStrategy": "App installs without errors; service appears in system Notification Access settings.",
      "status": "pending",
      "dependencies": [1],
      "priority": "high",
      "subtasks": []
    },
    {
      "id": 5,
      "title": "Initialize Firebase Anonymous Auth",
      "description": "Add Firebase Auth dependency. Initialize Firebase in Application class or MainActivity. Sign in anonymously on first launch. Persist auth state so subsequent launches reuse the same anonymous UID. This UID is required for calling Cloud Functions.",
      "details": "Enable Anonymous Auth in Firebase Console. In-app: FirebaseAuth.getInstance().signInAnonymously() on startup if currentUser == null.",
      "testStrategy": "After launch, FirebaseAuth.currentUser is non-null with an anonymous UID.",
      "status": "pending",
      "dependencies": [1],
      "priority": "high",
      "subtasks": []
    },
    {
      "id": 6,
      "title": "Define Data Models and Enums",
      "description": "Create all data model classes: (1) RiskLevel enum: HIGH, MEDIUM, LOW. (2) AlertSourceType enum: NOTIFICATION, GALLERY, MANUAL_LINK, MANUAL_IMAGE, MANUAL_CAMERA. (3) ScamCategory enum: INVESTMENT, IMPERSONATION, ROMANCE, PRIZE, DELIVERY, JOB, PHISHING, UNKNOWN. (4) ScamTactic enum: URGENCY, AUTHORITY, PAYMENT_PRESSURE, SECRECY, FEAR, GREED, OTHER. (5) AlertEntity (Room entity): id, createdAt, sourceType, rawSnippet, extractedUrl, riskLevel, category, tactics (List<ScamTactic>), reasons (List<String>), isReviewed. (6) GeminiExplanation data class: riskLevel, headline, whyFlagged, whatToDoNow, whatNotToDo, confidence, notes. (7) NewsItem entity: id, title, url, domain, imageUrl, retrievedAt, region (MY/GLOBAL). (8) ScanResult data class: riskLevel, category, tactics, extractedText, extractedUrl, reasons.",
      "details": "AlertEntity uses Room @Entity annotation. NewsItem uses Room @Entity. Other classes are plain Kotlin data classes. Need Room type converters for List<String>, List<ScamTactic>, enums.",
      "testStrategy": "All classes compile; Room schema generates without errors.",
      "status": "pending",
      "dependencies": [2, 3],
      "priority": "high",
      "subtasks": []
    },
    {
      "id": 7,
      "title": "Implement Room Database, DAOs, and Type Converters",
      "description": "Create: (1) RoomTypeConverters — convert List<String> to/from JSON string, List<ScamTactic> to/from JSON, RiskLevel to/from String, ScamCategory to/from String, AlertSourceType to/from String. (2) AlertDao — insert(alert), getAll(): Flow<List<AlertEntity>>, getById(id): Flow<AlertEntity?>, delete(id), getUnreviewed(): Flow<List<AlertEntity>>, getCountSince(timestamp): Flow<Int>, getCategoryCounts(): Flow<Map<String,Int>>. (3) NewsItemDao — insertAll(items), getByRegion(region): Flow<List<NewsItem>>, deleteOlderThan(timestamp), getLatestTimestamp(region): Long?. (4) SafeXDatabase extends RoomDatabase with entities AlertEntity and NewsItemEntity.",
      "details": "Use Kotlin Serialization or Gson for JSON conversion in type converters. Database version = 1. Export schema for debugging.",
      "testStrategy": "Room compiler generates implementation. Insert and query operations work in instrumented test.",
      "status": "pending",
      "dependencies": [6],
      "priority": "high",
      "subtasks": []
    },
    {
      "id": 8,
      "title": "Implement SettingsRepository with DataStore",
      "description": "Create SettingsRepository backed by Preferences DataStore. Stored values: (1) appMode: String (GUARDIAN/COMPANION), default GUARDIAN. (2) notificationMonitorEnabled: Boolean, default true. (3) galleryMonitorEnabled: Boolean, default true. (4) appLanguage: String (EN/MS/ZH), default EN. (5) onboardingComplete: Boolean, default false. (6) lastGalleryScanTimestamp: Long, default 0. Expose each as Flow<T> for reactive UI. Provide suspend setters for each.",
      "details": "Use androidx.datastore.preferences. Create a single DataStore instance (singleton). Keys defined as PreferenceKeys object.",
      "testStrategy": "Write a value, read it back via Flow, verify emission.",
      "status": "pending",
      "dependencies": [1, 3],
      "priority": "high",
      "subtasks": []
    },
    {
      "id": 9,
      "title": "Implement AlertRepository",
      "description": "Create AlertRepository that wraps AlertDao and exposes: (1) allAlerts: Flow<List<AlertEntity>>. (2) unreviewedAlerts: Flow<List<AlertEntity>>. (3) getAlertById(id): Flow<AlertEntity?>. (4) suspend insertAlert(alert): Long. (5) suspend deleteAlert(id). (6) threatsThisWeek: Flow<Int>. (7) categoryCounts: Flow<Map<String,Int>>.",
      "details": "Simple wrapper for now. Later can add caching or transformation logic.",
      "testStrategy": "Inject DAO mock, verify repository delegates correctly.",
      "status": "pending",
      "dependencies": [7],
      "priority": "high",
      "subtasks": []
    },
    {
      "id": 10,
      "title": "Set Up Compose Navigation with Bottom Bar (4-Tab Shell)",
      "description": "Implement NavHost in MainActivity with routes: home, alerts, alerts/{alertId} (detail), insights, settings, scan, onboarding. Create a BottomNavigationBar composable with 4 tabs (Home, Alerts, Insights, Settings) using Material3 NavigationBar. Handle tab selection and navigation state. Hide bottom bar during onboarding. Support deep-link navigation for alert notifications (alerts/{alertId}).",
      "details": "Use rememberNavController. Each tab has its own nested NavGraph if needed. AlertDetail is a separate route that accepts alertId as argument. Bottom bar should highlight active tab.",
      "testStrategy": "Tapping each tab navigates to the correct screen. Back navigation works correctly.",
      "status": "pending",
      "dependencies": [1, 3],
      "priority": "high",
      "subtasks": []
    },
    {
      "id": 11,
      "title": "Build HomeScreen UI",
      "description": "Implement HomeScreen composable with: (1) Status card showing protection status (ON/OFF based on Guardian mode + permissions), which monitors are enabled (Notification/Gallery badges), last scan time. (2) Primary 'Scan' CTA button that navigates to ScanScreen. (3) Summary section: 'Threats detected this week' count from AlertRepository, 'Last alert' preview (optional). Use ViewModel to collect state from SettingsRepository and AlertRepository.",
      "details": "Home must load < 1 second. Scan options accessible within 1 tap. Use Material3 Cards, Surface, and typography.",
      "testStrategy": "Home displays correct protection status. Scan button navigates to scan. Threat count updates when alerts change.",
      "status": "pending",
      "dependencies": [8, 9, 10],
      "priority": "medium",
      "subtasks": []
    },
    {
      "id": 12,
      "title": "Build AlertsScreen (List) UI",
      "description": "Implement AlertsScreen composable with: (1) LazyColumn of alert cards. (2) Each card shows: icon (message/image/link based on sourceType), headline (short, e.g. 'Potential investment scam'), timestamp (relative), risk badge (HIGH=red, MEDIUM=orange, LOW=green). (3) Tap card navigates to AlertDetailScreen(alertId). (4) Empty state: 'No alerts yet — you're safe!' message. Use ViewModel collecting from AlertRepository.unreviewedAlerts.",
      "details": "Alerts exist locally until reviewed. After review, alert is deleted automatically. Show only unreviewed alerts in the list.",
      "testStrategy": "List renders alerts from Room. Tapping an alert navigates to detail. Empty state shows when no alerts.",
      "status": "pending",
      "dependencies": [9, 10],
      "priority": "medium",
      "subtasks": []
    },
    {
      "id": 13,
      "title": "Build AlertDetailScreen UI",
      "description": "Implement AlertDetailScreen composable with: (1) Risk meter visual (HIGH/MEDIUM/LOW with color). (2) 'Why SafeX flagged this' section — bullet list from Gemini or local reasons. (3) 'What you should do now' — bullet list. (4) 'What NOT to do' — bullet list. (5) Optional: 'Detected link present — test in Scan' link. (6) Action buttons: 'Report' and 'Mark as safe'. (7) Loading state while Gemini loads. (8) Error/fallback state if Gemini fails — show generic hardcoded advice. Uses ViewModel that calls CloudFunctionsClient.explainAlert on screen open.",
      "details": "Gemini is called ONLY when detail screen opens (lazy load). If offline or error, show fallback: 'Be cautious with this message. Do not share personal info or click unknown links.' Report button calls reportAlert then deletes alert. Mark Safe just deletes alert.",
      "testStrategy": "Detail renders with Gemini data. Fallback renders on error. Report increments Firestore. Mark safe deletes from Room.",
      "status": "pending",
      "dependencies": [9, 10],
      "priority": "medium",
      "subtasks": []
    },
    {
      "id": 14,
      "title": "Build InsightsScreen UI",
      "description": "Implement InsightsScreen with 3 sections: (1) Personal summary (local): weekly alert count, top categories chart/list, top tactics. (2) Community trends (Firestore): top scam categories this week, top tactics, emerging patterns. Show 'No community data yet' if Firestore empty. (3) News feed: pull-to-refresh, 2 chips (Malaysia / Global), each item: title, source domain, optional image, 'Open' button (Chrome Custom Tab). Safety disclaimer always visible. Loading/offline/empty states for each section.",
      "details": "Personal section queries local Room. Community section queries Firestore insightsWeekly. News section calls GDELT API with Room cache (12h TTL). News links never auto-open.",
      "testStrategy": "Personal section shows correct local counts. Community section shows Firestore data or empty state. News shows cached or live data. Disclaimer always visible.",
      "status": "pending",
      "dependencies": [9, 10],
      "priority": "medium",
      "subtasks": []
    },
    {
      "id": 15,
      "title": "Build SettingsScreen UI",
      "description": "Implement SettingsScreen with: (1) Mode selection: Guardian/Companion radio/toggle. (2) Guardian-only section (visible only if Guardian): notification monitoring toggle with permission status (green/red), gallery monitoring toggle with permission status. Each toggle has 'Enable access' button that opens correct system page. (3) Language picker: EN/MS/ZH dropdown or dialog. (4) Privacy policy summary (static screen). (5) About SafeX (version, credits). (6) 'Reset local data' button with confirmation dialog.",
      "details": "Guardian toggles are hidden if mode is Companion. Permission status checks done via system APIs. Language change persists to DataStore and calls Activity.recreate(). No sensitivity slider in MVP.",
      "testStrategy": "Mode toggle updates DataStore. Permission states reflect reality. Language change applies immediately. Reset clears Room DB.",
      "status": "pending",
      "dependencies": [8, 10],
      "priority": "medium",
      "subtasks": []
    },
    {
      "id": 16,
      "title": "Build Shared UI Components",
      "description": "Create reusable composables: (1) RiskBadge(riskLevel) — colored chip (red/orange/green). (2) StatusCard — protection summary card with icon + text. (3) AlertCard — list item for alerts tab. (4) SectionHeader(title) — styled section title. (5) LoadingState — centered progress indicator with optional message. (6) ErrorState(message, retryAction) — error display with retry. (7) EmptyState(icon, message) — friendly empty screen. (8) SafeXTopAppBar — consistent top bar across screens.",
      "details": "Follow Material3 design tokens. Use SafeX color scheme from theme. All components should be @Preview annotated.",
      "testStrategy": "Each component renders correctly in Preview. Components are used across multiple screens.",
      "status": "pending",
      "dependencies": [10],
      "priority": "medium",
      "subtasks": []
    },
    {
      "id": 17,
      "title": "Implement Onboarding Flow",
      "description": "Create onboarding screens: (1) Intro pager (2-3 screens): explain SafeX value, privacy promise, Guardian concept. (2) Language selection: EN/MS/ZH. (3) Mode selection: Guardian vs Companion with clear descriptions. (4) If Guardian: permission request flow — POST_NOTIFICATIONS (Android 13+), then Notification Access (opens system settings), then Gallery permission (READ_MEDIA_IMAGES on 13+). (5) Finish → navigate to Home. Persist onboardingComplete flag to DataStore. Conditional start: if !onboardingComplete → Onboarding; else → Home.",
      "details": "Use HorizontalPager or custom navigation. Permission requests must be sequential and graceful if denied. Show explanation before each permission request. Don't block if user skips permissions — app still works in Companion mode.",
      "testStrategy": "First launch shows onboarding. Second launch skips to Home. All permissions requested in correct order. Skipping permissions still allows app to load.",
      "status": "pending",
      "dependencies": [8, 10, 15],
      "priority": "medium",
      "subtasks": []
    },
    {
      "id": 18,
      "title": "Create English Strings Resource (Complete)",
      "description": "Populate values/strings.xml with ALL UI strings: app name, tab labels (Home, Alerts, Insights, Settings), all button labels, all status messages, all onboarding text, all placeholder/empty state messages, all error messages, fallback Gemini advice text, scan screen labels, settings labels, privacy policy text, about text, notification channel name/description. Use descriptive resource names with prefixes (e.g., home_status_protected, alert_detail_why_flagged).",
      "details": "Must be comprehensive — no hardcoded strings in Kotlin/Compose code. Every user-visible string must be a resource. This is the base for MS/ZH translations.",
      "testStrategy": "Grep codebase for hardcoded strings — none found. All UI text comes from strings.xml.",
      "status": "pending",
      "dependencies": [10, 11, 12, 13, 14, 15, 17],
      "priority": "medium",
      "subtasks": []
    },
    {
      "id": 19,
      "title": "Create Malay (MS) String Resources",
      "description": "Create values-ms/strings.xml with full Malay translations of all strings from task 18.",
      "details": "Must cover every string. Use natural Malay phrasing, not machine translation. Pay special attention to scam-related terminology familiar to Malaysian users.",
      "testStrategy": "Switch language to MS — all UI text appears in Malay with no missing resources.",
      "status": "pending",
      "dependencies": [18],
      "priority": "low",
      "subtasks": []
    },
    {
      "id": 20,
      "title": "Create Chinese (ZH) String Resources",
      "description": "Create values-zh/strings.xml with full Chinese translations of all strings from task 18.",
      "details": "Use Simplified Chinese. Must cover every string. Use clear, non-technical language appropriate for elder users.",
      "testStrategy": "Switch language to ZH — all UI text appears in Chinese with no missing resources.",
      "status": "pending",
      "dependencies": [18],
      "priority": "low",
      "subtasks": []
    },
    {
      "id": 21,
      "title": "Implement In-App Language Switching",
      "description": "Implement language override logic: (1) Read appLanguage from DataStore. (2) Apply locale override using AppCompatDelegate or per-app language API (Android 13+). (3) On language change, persist new value to DataStore and call Activity.recreate(). (4) Ensure language applies on cold start too.",
      "details": "Use Android 13+ per-app language API where available, fallback to AppCompatDelegate for older versions. Language change must take effect immediately (Activity recreates).",
      "testStrategy": "Changing language in Settings updates all UI strings immediately. App reopens in same language after kill/restart.",
      "status": "pending",
      "dependencies": [8, 18],
      "priority": "medium",
      "subtasks": []
    },
    {
      "id": 22,
      "title": "Implement ML Kit OCR Pipeline",
      "description": "Create TextRecognitionHelper: (1) Accept InputImage (from URI, Bitmap, or CameraX). (2) Run ML Kit TextRecognition. (3) Return extracted text string. (4) Handle model not downloaded gracefully (auto-downloads on first use). (5) Handle empty images / no text found.",
      "details": "Use com.google.mlkit:text-recognition. InputImage.fromFilePath() for gallery images, InputImage.fromMediaImage() for CameraX frames.",
      "testStrategy": "Feed a test image with text → returns extracted text. Feed blank image → returns empty string without crash.",
      "status": "pending",
      "dependencies": [1],
      "priority": "high",
      "subtasks": []
    },
    {
      "id": 23,
      "title": "Implement ML Kit Barcode/QR Pipeline",
      "description": "Create BarcodeScanHelper: (1) Accept InputImage. (2) Run ML Kit BarcodeScanning (format: QR_CODE). (3) Extract URL values from detected barcodes. (4) Return List<String> of URLs found. (5) Handle no QR found gracefully.",
      "details": "Use com.google.mlkit:barcode-scanning. Focus on QR codes but also detect standard barcodes if URL payload present.",
      "testStrategy": "Feed QR image → returns URL. Feed image without QR → returns empty list.",
      "status": "pending",
      "dependencies": [1],
      "priority": "high",
      "subtasks": []
    },
    {
      "id": 24,
      "title": "Implement ML Kit Language Detection",
      "description": "Create LanguageDetectionHelper: (1) Accept text string. (2) Run ML Kit LanguageIdentification. (3) Return detected language code (e.g., 'en', 'ms', 'zh'). (4) Return 'und' (undetermined) if confidence too low.",
      "details": "Used to decide whether on-device translation is needed before running English-centric heuristics.",
      "testStrategy": "English text → 'en'. Malay text → 'ms'. Very short text → 'und'.",
      "status": "pending",
      "dependencies": [1],
      "priority": "medium",
      "subtasks": []
    },
    {
      "id": 25,
      "title": "Implement On-Device Translation (ML Kit)",
      "description": "Create TranslationHelper: (1) Accept text + source language code. (2) Translate to English using ML Kit Translation. (3) Handle model download: check if model exists, if not prompt/download (Wi-Fi recommended). (4) Return translated text or original if translation fails/unavailable.",
      "details": "Used for: (a) translating non-English notification text before heuristic triage, (b) optional headline translation in News feed. Models are ~30MB each, download on-demand.",
      "testStrategy": "Malay text translates to English after model download. If model not downloaded, returns original with error flag.",
      "status": "pending",
      "dependencies": [1, 24],
      "priority": "medium",
      "subtasks": []
    },
    {
      "id": 26,
      "title": "Build Keyword/Pattern Heuristic Engine",
      "description": "Create HeuristicEngine with pattern matching for scam detection: (1) Urgency patterns: 'act now', 'expires today', 'last chance', 'immediately', 'dalam 24 jam', etc. (2) Authority/impersonation: 'bank', 'police', 'LHDN', 'SSM', 'Pos Malaysia', 'your account', etc. (3) Payment pressure: 'transfer', 'payment required', 'send money', 'click to pay', etc. (4) Fear/threats: 'account locked', 'legal action', 'warrant', 'akaun ditutup', etc. (5) Greed/prize: 'you won', 'congratulations', 'guaranteed profit', 'high returns', etc. (6) Secrecy: 'don't tell anyone', 'keep this private', 'secret'. Include multilingual keywords (EN, MS, ZH). Return detected tactics list and a heuristic score (0-1).",
      "details": "Use regex patterns with word boundaries. Score = weighted count of matched patterns normalized. Support English + Malay + Chinese keywords. Keep patterns in a data structure that's easy to update.",
      "testStrategy": "Feed scam text → high score + correct tactics. Feed normal text → low score. Feed Malay scam text → detected.",
      "status": "pending",
      "dependencies": [6],
      "priority": "high",
      "subtasks": []
    },
    {
      "id": 27,
      "title": "Build TFLite Scam Intent Classifier",
      "description": "Create or source a TFLite text classification model for scam intent: (1) Define training data format (text, label: scam/not_scam or multi-class). (2) Train model using TensorFlow/Keras or TFLite Model Maker with a scam text dataset. (3) Export as .tflite file. (4) Place in app/src/main/assets/. (5) Create TFLiteClassifier class that loads the model, tokenizes input text, runs inference, and returns a scam probability score (0-1). (6) Combine with heuristic score for final risk assessment.",
      "details": "If a suitable pre-trained model or public scam dataset is not available, create a small training set from known scam patterns and train a simple NLP model. The model should work on short text (notification previews, ~100 chars). Use TFLite Task Library for easier integration.",
      "testStrategy": "Model loads without crash. Scam text returns score > 0.7. Normal text returns score < 0.3. Inference time < 200ms.",
      "status": "pending",
      "dependencies": [1, 6],
      "priority": "medium",
      "subtasks": []
    },
    {
      "id": 28,
      "title": "Implement Combined RiskClassifier",
      "description": "Create RiskClassifier that combines heuristic and TFLite scores: (1) Accept input text + metadata (has URL, source type). (2) Run HeuristicEngine → heuristicScore + detectedTactics. (3) Run TFLiteClassifier → mlScore. (4) Combined score = weighted average (e.g., 0.4*heuristic + 0.6*ml). (5) URL presence adds bonus to score. (6) Map score to RiskLevel: >= 0.7 → HIGH, >= 0.4 → MEDIUM, else LOW. (7) Classify category based on matched patterns → ScamCategory enum. (8) Return full ScanResult object.",
      "details": "Thresholds should be configurable. MVP: alert only on HIGH (optionally MEDIUM). Total classification time must be < 500ms.",
      "testStrategy": "Scam text → HIGH risk. Normal text → LOW. Borderline text → MEDIUM. Category classification matches expected type.",
      "status": "pending",
      "dependencies": [26, 27],
      "priority": "high",
      "subtasks": []
    },
    {
      "id": 29,
      "title": "Implement SafeXNotificationListenerService",
      "description": "Create NotificationListenerService subclass: (1) Override onNotificationPosted. (2) Extract android.title and android.text from notification extras. (3) Filter out SafeX's own package notifications. (4) Filter out system/media notifications (optional whitelist of messenger package names). (5) Detect language using LanguageDetectionHelper. (6) If non-English, translate to English using TranslationHelper. (7) Run text through RiskClassifier. (8) If HIGH risk: create AlertEntity (sourceType=NOTIFICATION, rawSnippet=preview text, extractedUrl if found) and insert into Room via AlertRepository. (9) Post SafeX warning notification. (10) Respect Guardian mode + notification toggle from DataStore.",
      "details": "Service runs in background. Must be efficient (< 500ms per notification). Check DataStore synchronously (blocking read OK for service since it's a single value). Handle edge cases: null extras, empty text, very long text (truncate to 500 chars).",
      "testStrategy": "Receive test scam notification → alert created in Room + warning notification posted. Normal notification → no alert. SafeX notification → ignored.",
      "status": "pending",
      "dependencies": [4, 8, 9, 24, 25, 28],
      "priority": "high",
      "subtasks": []
    },
    {
      "id": 30,
      "title": "Implement Warning Notification Builder",
      "description": "Create NotificationHelper class: (1) Create notification channel 'safex_alerts' with HIGH importance on app startup. (2) Build warning notification: icon, title ('SafeX Warning'), body (alert headline), auto-cancel. (3) Attach PendingIntent that opens MainActivity with extras: alertId, navigateTo='alertDetail'. (4) Use unique notification ID per alert. (5) Handle POST_NOTIFICATIONS permission check before posting.",
      "details": "PendingIntent must use FLAG_IMMUTABLE (API 31+). Use FLAG_UPDATE_CURRENT to avoid stale intents. Notification channel should be created in Application.onCreate or MainActivity.onCreate.",
      "testStrategy": "Warning notification appears in system tray. Tapping it opens app to the correct alert detail.",
      "status": "pending",
      "dependencies": [4, 9],
      "priority": "high",
      "subtasks": []
    },
    {
      "id": 31,
      "title": "Implement Deep-Link Navigation from Notification",
      "description": "Handle notification tap in MainActivity: (1) In onCreate and onNewIntent, check for alertId and navigateTo extras. (2) If present, navigate NavController to alerts/{alertId} route. (3) Ensure this works both when app is cold-started and when already running (onNewIntent). (4) Clear the intent extras after handling to prevent re-navigation on config change.",
      "details": "Use LaunchedEffect or SideEffect in Compose to trigger navigation after NavHost is ready. Handle the timing carefully — NavHost must be composed before navigation can happen.",
      "testStrategy": "Cold start from notification → opens alert detail. Warm start from notification → navigates to alert detail. Rotating device doesn't re-navigate.",
      "status": "pending",
      "dependencies": [10, 30],
      "priority": "high",
      "subtasks": []
    },
    {
      "id": 32,
      "title": "Implement GalleryScanWorker (WorkManager)",
      "description": "Create PeriodicWorkRequest worker: (1) Query MediaStore.Images for images added since lastGalleryScanTimestamp (from DataStore). (2) For each new image (max 20 per run): run OCR pipeline → extract text, run QR pipeline → extract URLs, run RiskClassifier on combined text. (3) If HIGH risk: insert AlertEntity (sourceType=GALLERY) into Room, post warning notification. (4) Update lastGalleryScanTimestamp in DataStore. (5) Use WorkManager constraints: battery not low, device not in doze.",
      "details": "Periodic interval: 15 minutes (minimum for WorkManager). Cap at 20 images per run to limit battery impact. Sort images by date descending to scan newest first.",
      "testStrategy": "Save a scam image to gallery → within 15 min, alert appears. Normal images → no alert. Battery-low → worker deferred.",
      "status": "pending",
      "dependencies": [8, 9, 22, 23, 28, 30],
      "priority": "high",
      "subtasks": []
    },
    {
      "id": 33,
      "title": "Implement GalleryMonitorScheduler",
      "description": "Create utility to schedule/cancel gallery scanning work: (1) When Guardian mode ON + gallery toggle ON → enqueue unique periodic work. (2) When Guardian mode OFF or gallery toggle OFF → cancel unique work. (3) Call from SettingsScreen when toggles change. (4) Call on app startup based on current settings.",
      "details": "Use WorkManager.enqueueUniquePeriodicWork with ExistingPeriodicWorkPolicy.KEEP to avoid duplicates.",
      "testStrategy": "Enable gallery toggle → work scheduled. Disable → work cancelled. Re-enable → work re-scheduled.",
      "status": "pending",
      "dependencies": [32],
      "priority": "medium",
      "subtasks": []
    },
    {
      "id": 34,
      "title": "Build ScanScreen UI (Manual Scan)",
      "description": "Create ScanScreen with 3 scan options: (1) 'Paste Link' button/card → opens text input field + 'Check' button. (2) 'Choose Image' button/card → launches Photo Picker (ActivityResultContracts.PickVisualMedia). (3) 'Scan with Camera' button/card → navigates to CameraScanScreen. Design as bottom sheet from Home or as dedicated screen.",
      "details": "Each option leads to a scan result display. Accessible within 1 tap from Home.",
      "testStrategy": "All 3 options visible and tappable. Photo picker launches. Camera screen opens.",
      "status": "pending",
      "dependencies": [10, 16],
      "priority": "medium",
      "subtasks": []
    },
    {
      "id": 35,
      "title": "Implement Paste Link Scan Flow",
      "description": "Create link scanning: (1) User pastes URL into text field. (2) Validate URL format. (3) Call Safe Browsing check (via Cloud Function or direct API). (4) Display result: SAFE (green) / SUSPICIOUS (orange) / DANGEROUS (red). (5) If dangerous/suspicious, offer 'Save to Alerts' button that creates a manual alert in Room.",
      "details": "Use Google Safe Browsing Lookup API v4. Can be called directly from the app or via a Cloud Function wrapper. Show loading state during check.",
      "testStrategy": "Known bad URL → DANGEROUS. Normal URL → SAFE. Save to Alerts creates correct AlertEntity.",
      "status": "pending",
      "dependencies": [9, 34],
      "priority": "medium",
      "subtasks": []
    },
    {
      "id": 36,
      "title": "Implement Image Scan Flow (Gallery Pick)",
      "description": "Create image scan flow: (1) User picks image via Photo Picker. (2) Run OCR pipeline on selected image. (3) Run QR pipeline on selected image. (4) Feed extracted text + URLs to RiskClassifier. (5) Display ScanResult screen: risk level, extracted text preview, detected category/tactics, reasons. (6) If flagged, offer 'Save to Alerts'.",
      "details": "Use ActivityResultContracts.PickVisualMedia(). Convert URI to InputImage for ML Kit processing. Show progress indicator during scan.",
      "testStrategy": "Pick scam image → shows HIGH risk result. Pick normal image → shows LOW/no risk. Results include extracted text.",
      "status": "pending",
      "dependencies": [22, 23, 28, 34],
      "priority": "medium",
      "subtasks": []
    },
    {
      "id": 37,
      "title": "Implement Camera Scan Flow (CameraX)",
      "description": "Create CameraScanScreen: (1) CameraX preview (back camera). (2) Real-time QR/barcode detection overlay using ML Kit BarcodeScanning with CameraX ImageAnalysis. (3) On QR detected: extract URL, auto-pause camera, show result. (4) Also capture frame for OCR on user tap ('Capture & Scan' button). (5) Feed results to RiskClassifier. (6) Display scan result with option to save to alerts.",
      "details": "Use CameraX with ImageAnalysis use case for real-time barcode detection. For OCR, take a single capture frame. Handle camera permission request if not granted. Handle camera errors gracefully.",
      "testStrategy": "Point at QR code → URL extracted. Tap capture → OCR runs. Results displayed correctly.",
      "status": "pending",
      "dependencies": [22, 23, 28, 34],
      "priority": "medium",
      "subtasks": []
    },
    {
      "id": 38,
      "title": "Build Scan Result Screen",
      "description": "Create ScanResultScreen composable: (1) Risk level visual indicator (traffic light style). (2) Extracted text preview (truncated). (3) Extracted URL(s) if any. (4) Detected category + tactics tags. (5) Reason bullets (why flagged). (6) 'Save to Alerts' button (if risk >= MEDIUM). (7) 'Scan Another' button to go back to ScanScreen.",
      "details": "Reuse RiskBadge and other shared components. Should feel consistent with AlertDetailScreen.",
      "testStrategy": "Result screen displays all fields correctly. Save to Alerts creates alert and navigates to Alerts tab.",
      "status": "pending",
      "dependencies": [13, 16, 34],
      "priority": "medium",
      "subtasks": []
    },
    {
      "id": 39,
      "title": "Implement explainAlert Cloud Function",
      "description": "Create Firebase callable Cloud Function 'explainAlert': (1) Accept parameters: alertType, category, tactics[], redactedSnippet (max 500 chars), extractedUrl (optional). (2) Validate inputs: check required fields, enforce max lengths, strip PII. (3) Build Gemini prompt: structured system instruction requesting JSON output with schema {riskLevel, headline, whyFlagged[], whatToDoNow[], whatNotToDo[], confidence, notes}. Prompt should instruct calm, clear, non-alarmist language. (4) Call Gemini via Google Gen AI SDK (Vertex AI). (5) Parse Gemini JSON response. (6) Return parsed result to client. (7) On Gemini error: return fallback response with generic advice.",
      "details": "Use @google-cloud/vertexai or @google/generative-ai npm package. Function must require Firebase Auth. Prompt should include examples of good output format. Set temperature low (0.2-0.3) for consistency. Max tokens ~500.",
      "testStrategy": "Call with test scam data → returns valid JSON with all fields. Call with empty/invalid data → returns validation error. Gemini timeout → returns fallback.",
      "status": "pending",
      "dependencies": [],
      "priority": "high",
      "subtasks": []
    },
    {
      "id": 40,
      "title": "Implement reportAlert Cloud Function",
      "description": "Create Firebase callable Cloud Function 'reportAlert': (1) Accept parameters: category (ScamCategory), tactics[] (ScamTactic[]), maskedDomain (optional string). (2) Validate inputs against allowed enums. (3) Calculate weekId (e.g., '2026-W06'). (4) Atomically increment counters in Firestore doc insightsWeekly/{weekId}: totalReports++, categoryCounts.{category}++, tacticCounts.{tactic}++ for each tactic, topMaskedDomains array append (with dedup/limit). (5) Rate limit: max 10 reports per UID per hour. (6) Require Firebase Auth.",
      "details": "Use Firestore FieldValue.increment() for atomic counter updates. Use Firestore transactions for array operations. WeekId format: ISO year + week number.",
      "testStrategy": "Call with valid data → Firestore counters increment. Call 11 times in an hour → 11th call rejected. Invalid category → validation error.",
      "status": "pending",
      "dependencies": [],
      "priority": "high",
      "subtasks": []
    },
    {
      "id": 41,
      "title": "Update Firestore Security Rules for insightsWeekly",
      "description": "Add Firestore rules for insightsWeekly collection: (1) Read: allow if authenticated (for Insights tab to query). (2) Write: deny from client (only Cloud Functions can write via admin SDK). Add to existing firestore.rules file.",
      "details": "Existing rules cover threat_intel, reputation_domains, and reports. Add insightsWeekly alongside them.",
      "testStrategy": "Authenticated client can read insightsWeekly docs. Client write attempt is rejected. Cloud Function write succeeds.",
      "status": "pending",
      "dependencies": [40],
      "priority": "medium",
      "subtasks": []
    },
    {
      "id": 42,
      "title": "Implement CloudFunctionsClient (Android)",
      "description": "Create CloudFunctionsClient.kt: (1) explainAlert(alertType, category, tactics, snippet, url) → GeminiExplanation. (2) reportAlert(category, tactics, maskedDomain) → Boolean success. Uses Firebase Functions SDK (FirebaseFunctions.getInstance().getHttpsCallable()). Parse JSON responses into Kotlin data classes. Handle errors: network, auth, function errors. Provide timeout (10s for explain, 5s for report).",
      "details": "Use kotlinx.serialization or Gson to parse function responses. Suspend functions for coroutine integration.",
      "testStrategy": "explainAlert returns parsed GeminiExplanation. reportAlert returns success. Network error handled gracefully.",
      "status": "pending",
      "dependencies": [5, 6, 39, 40],
      "priority": "high",
      "subtasks": []
    },
    {
      "id": 43,
      "title": "Integrate Gemini Explanation into AlertDetailScreen",
      "description": "Wire up AlertDetailScreen ViewModel: (1) On screen open, call CloudFunctionsClient.explainAlert with alert data. (2) Show loading state while waiting. (3) On success, display structured explanation (whyFlagged, whatToDoNow, whatNotToDo, confidence). (4) On error, show fallback hardcoded advice. (5) Cache explanation in AlertEntity.geminiExplanation field to avoid re-calling on screen revisit.",
      "details": "Gemini call is lazy — only triggered when user opens alert detail, not at detection time. This minimizes API costs.",
      "testStrategy": "Open alert detail → loading → explanation renders. Kill network → open alert → fallback advice shows. Reopen same alert → cached explanation, no API call.",
      "status": "pending",
      "dependencies": [13, 42],
      "priority": "high",
      "subtasks": []
    },
    {
      "id": 44,
      "title": "Integrate Report Flow into AlertDetailScreen",
      "description": "Wire up Report button: (1) User taps 'Report'. (2) Show confirmation dialog. (3) Call CloudFunctionsClient.reportAlert with alert's category, tactics, masked domain. (4) On success: show success toast, delete alert from Room, navigate back to Alerts list. (5) On error: show error message, don't delete alert. Also wire up 'Mark as Safe': delete alert from Room without reporting, navigate back.",
      "details": "Report sends only aggregated metadata, never raw content. Masked domain = extract domain, mask middle (e.g., 'ban*.com').",
      "testStrategy": "Report → Firestore counters increment → alert deleted → back to list. Mark Safe → alert deleted, no Firestore call. Report failure → alert preserved.",
      "status": "pending",
      "dependencies": [13, 42],
      "priority": "high",
      "subtasks": []
    },
    {
      "id": 45,
      "title": "Implement InsightsRepository (Firestore + Local)",
      "description": "Create InsightsRepository: (1) Personal insights: query AlertRepository for local counts (this week alerts, category breakdown, tactic breakdown). (2) Community insights: query Firestore insightsWeekly/{currentWeekId} → expose as Flow with loading/error states. (3) Calculate currentWeekId from system date. (4) Handle empty Firestore gracefully ('No community data yet').",
      "details": "Use Firestore snapshot listeners for real-time community data updates. Combine local and remote data into InsightsState data class.",
      "testStrategy": "Personal section shows correct local counts. Community section loads Firestore data. Empty Firestore → graceful empty state.",
      "status": "pending",
      "dependencies": [9, 41],
      "priority": "medium",
      "subtasks": []
    },
    {
      "id": 46,
      "title": "Implement NewsRepository (GDELT API + Room Cache)",
      "description": "Create NewsRepository: (1) Fetch news from GDELT DOC 2.0 API: URL format https://api.gdeltproject.org/api/v2/doc/doc?query=scam+fraud&mode=ArtList&maxrecords=20&format=json. (2) For Malaysia filter: add '&sourcecountry:malaysia'. (3) Parse JSON response into NewsItem objects. (4) Cache in Room via NewsItemDao. (5) TTL: 12 hours — if cache is fresh, return cached data. (6) On fetch error, return cached data if available, else empty state. (7) Expose as Flow<List<NewsItem>> per region.",
      "details": "GDELT API is free, no key needed. Use Retrofit or OkHttp for HTTP calls. Parse GDELT's JSON format (articles array with url, title, domain, socialimage fields).",
      "testStrategy": "First call fetches from API + caches. Second call within 12h returns cache. Pull-to-refresh force-fetches. Offline returns cache.",
      "status": "pending",
      "dependencies": [1, 7],
      "priority": "medium",
      "subtasks": []
    },
    {
      "id": 47,
      "title": "Wire Up InsightsScreen with Real Data",
      "description": "Connect InsightsScreen to InsightsRepository and NewsRepository: (1) Personal section uses local Flow data. (2) Community section uses Firestore Flow data. (3) News section uses GDELT Flow data with region filter chips. (4) Pull-to-refresh refreshes news and community data. (5) 'Open' button on news item launches Chrome Custom Tab. (6) Safety disclaimer always visible. (7) All sections handle loading/error/empty states independently.",
      "details": "Use InsightsViewModel. Collect 3 separate state flows in the screen. Chrome Custom Tab requires CustomTabsIntent.Builder.",
      "testStrategy": "All 3 sections show real or mock data. Region chips filter news correctly. Open link launches browser. Disclaimer visible.",
      "status": "pending",
      "dependencies": [14, 45, 46],
      "priority": "medium",
      "subtasks": []
    },
    {
      "id": 48,
      "title": "Create Debug Fake Data Injection Tool",
      "description": "Create a debug-only tool for testing/demo: (1) Debug menu or build-flag-gated screen that allows inserting sample scam alerts into Room. (2) Pre-built alert samples: investment scam notification, phishing SMS, romance scam image, fake delivery tracking. (3) Each sample has realistic rawSnippet, category, tactics, riskLevel. (4) Option to clear all test data. Only available in debug builds.",
      "details": "Wrap in BuildConfig.DEBUG check. Useful for demo preparation and testing without actual scam notifications.",
      "testStrategy": "Debug build shows tool. Insert samples → appear in Alerts. Release build has no trace of this tool.",
      "status": "pending",
      "dependencies": [9, 12],
      "priority": "low",
      "subtasks": []
    },
    {
      "id": 49,
      "title": "Crash & Edge Case Hardening",
      "description": "Systematically handle edge cases: (1) ML Kit models not downloaded → graceful fallback (show message, don't crash). (2) Gemini timeout/error → fallback advice in alert detail. (3) Empty notification text → skip processing. (4) Null intent extras → don't crash. (5) Firestore empty → 'No community data yet'. (6) News API down → show cached or empty state. (7) Camera permission denied → show explanation and fallback. (8) DataStore corruption → rebuild with defaults. (9) Room migration (future-proofing). (10) Very long text inputs → truncate at 500 chars.",
      "details": "Add try-catch blocks in all ML Kit, network, and Firestore calls. Use Kotlin Result or sealed class for error handling.",
      "testStrategy": "Each scenario tested manually: airplane mode, permissions denied, first launch without models, rapid navigation.",
      "status": "pending",
      "dependencies": [29, 32, 43, 47],
      "priority": "medium",
      "subtasks": []
    },
    {
      "id": 50,
      "title": "Performance Optimization & Validation",
      "description": "Validate and optimize: (1) Notification triage < 500ms end-to-end (measure and optimize). (2) Home screen loads < 1 second on mid-range device. (3) Image scan shows progress indicator, completes in reasonable time. (4) Gallery worker processes max 20 images per run. (5) Gemini explanation loads within 5 seconds. (6) News feed loads within 3 seconds or shows cache. Profile using Android Profiler.",
      "details": "Use System.nanoTime() or Trace API for measurement. Optimize hot paths. Ensure Compose recompositions are minimal.",
      "testStrategy": "Benchmark measurements meet targets on a mid-range device (e.g., Pixel 4a or similar).",
      "status": "pending",
      "dependencies": [29, 32, 43, 47],
      "priority": "medium",
      "subtasks": []
    },
    {
      "id": 51,
      "title": "Unit Tests",
      "description": "Write unit tests for core logic: (1) HeuristicEngine: scam text → high score, normal text → low score, multilingual patterns. (2) RiskClassifier: combined scoring, threshold mapping, category classification. (3) AlertRepository: CRUD operations via mocked DAO. (4) SettingsRepository: read/write via mocked DataStore. (5) CloudFunctionsClient: response parsing, error handling. (6) WeekId calculation. (7) Domain masking logic.",
      "details": "Use JUnit 4, Mockito/MockK, kotlinx-coroutines-test. Target coverage for detection and data layer.",
      "testStrategy": "All tests pass. Key business logic has > 80% branch coverage.",
      "status": "pending",
      "dependencies": [26, 28, 9, 42],
      "priority": "low",
      "subtasks": []
    },
    {
      "id": 52,
      "title": "End-to-End Demo Script Validation",
      "description": "Walk through the exact 2-minute demo script from the PRD and verify every step works: (1) Open SafeX → Home shows summary + scan (2) Enable Guardian mode (notification monitoring) (3) Trigger scam notification → SafeX warning appears (4) Tap notification → Alerts → Alert detail (5) Gemini explanation renders (6) Tap Report → Insights tab → counters updated. Document any issues and fix them.",
      "details": "Test on physical device. Record the demo flow. Prepare backup test data in case live detection doesn't trigger in time.",
      "testStrategy": "Full demo completes without errors, crashes, or awkward pauses within 2 minutes.",
      "status": "pending",
      "dependencies": [49, 50],
      "priority": "high",
      "subtasks": []
    }
  ]
}
